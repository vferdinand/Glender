<html>

<head>
<title>HTWK Computergrafik, WebGL: &Uuml;bung Geometrie I</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-min.js"></script>

<!-- Vertex Shader: Beschreibt die Transformation der Vertices -->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 color;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix *
        vec4(aVertexPosition, 1.0);
	color = aVertexColor;
    }
</script>

<!-- Fragment Shader: Beschreibt die Einfärbung der Pixel -->
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 color;

    void main(void) {
        gl_FragColor = color;
    }
</script>


<script type="text/javascript">

    var gl;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Ich kann den WebGL-Kontext nicht initialisieren!");
        }
    }


    /* Holt sich mittels id den Shader aus dem DOM und konvertiert
       ihn in eine Zeichenkette. Dann wird dieser kompiliert.
       Gibt einen Verweis auf den kompilierten Shader zurück oder
       null bei Misserfolg.
     */
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    // globale Variable für das Shaderprogramm
    var shaderProgram;

    // initialisiert die beiden Shader aus dem DOM
    // und erzeugt daraus ein Shaderprogramm

    // holt zusätzlich die Verweise auf die Variablen
    // aus dem Shader und speichert diese in der Struktur
    // shaderProgram
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
	shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);


        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }


    // gobale Variablen für die Matrix-Uniforms
    var mvMatrix = glMatrix.mat4.create();
    var pMatrix = glMatrix.mat4.create();

    // setzt die Uniform-Variablen im Shader aus den globalen Variablen
    function setUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


    // Daten für Dreieck (Position)
    var triangleVertexPositionBuffer;
    var triangleVertexColorBuffer;
    // Daten für Würfel (Position, Punktindizes)
    var cubeVertexPositionBuffer;
	  var indexVertexPositionBuffer;


    function initBuffers() {
        // Erzeugen eines Puffers für Dreieckspositionen
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
             0.0,  1.0,  0.0,
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 3;

        // Erzeugen eines Puffers für Dreieckspositionen
        triangleVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
        var colors = [
             0.0,  0.0,  1.0, 1.0,
            1.0, 1.0,  0.0, 1.0,
             0.0, 0.0,  1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

		// Erzeuge einen Puffer mit den Positionen des Wuerfels
        cubeVertexPositionBuffer = gl.createBuffer();
		// Binde den Puffer fuer Vertexkoordinaten
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  1.0,
             1.0,  1.0,  -1.0,
             1.0, -1.0,  1.0,
             1.0, -1.0,  -1.0,
             -1.0,  1.0,  1.0,
             -1.0,  1.0,  -1.0,
             -1.0, -1.0,  1.0,
             -1.0, -1.0,  -1.0
        ];
		// lade Daten hoch
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);


        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 8;

		// erzeuge einen Puffer mit Indizes des Wuerfels
        indexVertexPositionBuffer = gl.createBuffer();
		// binde den Puffer als Puffer Elementindizes, die auf den Arraypuffer verweisen
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexVertexPositionBuffer);
        indices = [
            0, 1,
            0, 2,
            0, 4,
            1, 3,
            1, 5,
            2, 3,
            2, 6,
            3, 7,
            4, 5,
            4, 6,
            5, 7,
            6, 7
        ];
		// lade die Elementindizes hoch
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(indices), gl.STATIC_DRAW);
    }


    function drawScene() {
        gl.viewport(100, 20, gl.viewportWidth-100, gl.viewportHeight);

        gl.clearColor(0.0, 0.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        glMatrix.mat4.perspective(pMatrix, 50, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
	      // glMatrix.mat4.ortho(-5,5,-5,5,-100,100, pMatrix);

        glMatrix.mat4.identity(mvMatrix);

        glMatrix.mat4.translate(mvMatrix, mvMatrix, [-0.5, 0.5, -7.0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        
	gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);

        setUniforms();

        gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems );


        // Multiplikation mit Identitaet (macht nichts)
        theta = 30/180 * Math.PI;
        glMatrix.mat4.multiply(mvMatrix, mvMatrix,
               [Math.cos(theta), -Math.sin(theta), 0, 0,
                Math.sin(theta), Math.cos(theta), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1]);

        // aktiviere Vertexelement
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        // aktiviere die Indexliste
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexVertexPositionBuffer);
        //
        // setze Zustand der Grafikkarte, sodass Linien mit 5 Pixel Breite auf dem Bildschirm angezeigt werden
        gl.lineWidth( 5 );

        setUniforms();
        gl.uniform4f(shaderProgram.color, 1.0, 0.0, 1.0, 1.0);
        // Zeiche Linien mit Hilfe der Puffer
        gl.drawElements(gl.LINES, 24 /* Anzahl der Indizes */, gl.UNSIGNED_SHORT /* Datentyp der Indizes */, 0 /* nullptr = verwende ELEMENT_ARRAY */ );
    }



    function webGLStart() {
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        initBuffers();

        gl.clearColor(0.0, 0.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        drawScene();
    }


</script>


</head>

<!-- Die Darstellung besteht im Wesentlichen aus einem Zeichenfeld -->
<!-- Zum Initialisieren wird webGLStart() aufgerufen               -->
<body onload="webGLStart();">

    <canvas id="canvas" style="border: none;" width="800" height="800"></canvas>

</body>

</html>
